/* soapStub.h
   Generated by gSOAP 2.8.16 from ndfd.h

Copyright(C) 2000-2013, Robert van Engelen, Genivia Inc. All Rights Reserved.
The generated code is released under one of the following licenses:
GPL or Genivia's license for commercial use.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
*/

#ifndef soapStub_H
#define soapStub_H
#include <vector>
#define SOAP_NAMESPACE_OF_ns2	"http://graphical.weather.gov/xml/DWMLgen/schema/DWML.xsd"
#include "stdsoap2.h"
#if GSOAP_VERSION != 20816
# error "GSOAP VERSION MISMATCH IN GENERATED CODE: PLEASE REINSTALL PACKAGE"
#endif


/******************************************************************************\
 *                                                                            *
 * Enumerations                                                               *
 *                                                                            *
\******************************************************************************/


#ifndef SOAP_TYPE_ns2__sectorType
#define SOAP_TYPE_ns2__sectorType (13)
/* ns2:sectorType */
enum ns2__sectorType { ns2__sectorType__conus = 0, ns2__sectorType__nhemi = 1, ns2__sectorType__alaska = 2, ns2__sectorType__guam = 3, ns2__sectorType__hawaii = 4, ns2__sectorType__puertori = 5, ns2__sectorType__npacocn = 6 };
#endif

#ifndef SOAP_TYPE_ns2__unitType
#define SOAP_TYPE_ns2__unitType (14)
/* ns2:unitType */
enum ns2__unitType { ns2__unitType__e = 0, ns2__unitType__m = 1 };
#endif

#ifndef SOAP_TYPE_ns2__formatType
#define SOAP_TYPE_ns2__formatType (15)
/* ns2:formatType */
enum ns2__formatType { ns2__formatType__24_x0020hourly = 0, ns2__formatType__12_x0020hourly = 1 };
#endif

#ifndef SOAP_TYPE_ns2__productType
#define SOAP_TYPE_ns2__productType (16)
/* ns2:productType */
enum ns2__productType { ns2__productType__time_series = 0, ns2__productType__glance = 1 };
#endif

#ifndef SOAP_TYPE_ns2__featureTypeType
#define SOAP_TYPE_ns2__featureTypeType (21)
/* ns2:featureTypeType */
enum ns2__featureTypeType { ns2__featureTypeType__Forecast_USCOREGml2Point = 0, ns2__featureTypeType__Forecast_USCOREGml2AllWx = 1, ns2__featureTypeType__Forecast_USCOREGmlsfPoint = 2, ns2__featureTypeType__Forecast_USCOREGmlObs = 3, ns2__featureTypeType__NdfdMultiPointCoverage = 4, ns2__featureTypeType__Ndfd_USCOREKmlPoint = 5 };
#endif

#ifndef SOAP_TYPE_ns2__compTypeType
#define SOAP_TYPE_ns2__compTypeType (22)
/* ns2:compTypeType */
enum ns2__compTypeType { ns2__compTypeType__IsEqual = 0, ns2__compTypeType__Between = 1, ns2__compTypeType__GreaterThan = 2, ns2__compTypeType__GreaterThanEqualTo = 3, ns2__compTypeType__LessThan = 4, ns2__compTypeType__LessThanEqualTo = 5 };
#endif

#ifndef SOAP_TYPE_ns2__displayLevelType
#define SOAP_TYPE_ns2__displayLevelType (24)
/* ns2:displayLevelType */
enum ns2__displayLevelType { ns2__displayLevelType__1 = 1, ns2__displayLevelType__2 = 2, ns2__displayLevelType__3 = 3, ns2__displayLevelType__4 = 4, ns2__displayLevelType__12 = 12, ns2__displayLevelType__34 = 34, ns2__displayLevelType__1234 = 1234 };
#endif

/******************************************************************************\
 *                                                                            *
 * Types with Custom Serializers                                              *
 *                                                                            *
\******************************************************************************/


/******************************************************************************\
 *                                                                            *
 * Classes and Structs                                                        *
 *                                                                            *
\******************************************************************************/


#if 0 /* volatile type: do not declare here, declared elsewhere */

#endif

#if 0 /* volatile type: do not declare here, declared elsewhere */

#endif

#ifndef SOAP_TYPE_ns2__weatherParametersType
#define SOAP_TYPE_ns2__weatherParametersType (12)
/* ns2:weatherParametersType */
class SOAP_CMAC ns2__weatherParametersType
{
public:
	bool maxt;	/* required element of type xsd:boolean */
	bool mint;	/* required element of type xsd:boolean */
	bool temp;	/* required element of type xsd:boolean */
	bool dew;	/* required element of type xsd:boolean */
	bool pop12;	/* required element of type xsd:boolean */
	bool qpf;	/* required element of type xsd:boolean */
	bool sky;	/* required element of type xsd:boolean */
	bool snow;	/* required element of type xsd:boolean */
	bool wspd;	/* required element of type xsd:boolean */
	bool wdir;	/* required element of type xsd:boolean */
	bool wx;	/* required element of type xsd:boolean */
	bool waveh;	/* required element of type xsd:boolean */
	bool icons;	/* required element of type xsd:boolean */
	bool rh;	/* required element of type xsd:boolean */
	bool appt;	/* required element of type xsd:boolean */
	bool incw34;	/* required element of type xsd:boolean */
	bool incw50;	/* required element of type xsd:boolean */
	bool incw64;	/* required element of type xsd:boolean */
	bool cumw34;	/* required element of type xsd:boolean */
	bool cumw50;	/* required element of type xsd:boolean */
	bool cumw64;	/* required element of type xsd:boolean */
	bool critfireo;	/* required element of type xsd:boolean */
	bool dryfireo;	/* required element of type xsd:boolean */
	bool conhazo;	/* required element of type xsd:boolean */
	bool ptornado;	/* required element of type xsd:boolean */
	bool phail;	/* required element of type xsd:boolean */
	bool ptstmwinds;	/* required element of type xsd:boolean */
	bool pxtornado;	/* required element of type xsd:boolean */
	bool pxhail;	/* required element of type xsd:boolean */
	bool pxtstmwinds;	/* required element of type xsd:boolean */
	bool ptotsvrtstm;	/* required element of type xsd:boolean */
	bool pxtotsvrtstm;	/* required element of type xsd:boolean */
	bool tmpabv14d;	/* required element of type xsd:boolean */
	bool tmpblw14d;	/* required element of type xsd:boolean */
	bool tmpabv30d;	/* required element of type xsd:boolean */
	bool tmpblw30d;	/* required element of type xsd:boolean */
	bool tmpabv90d;	/* required element of type xsd:boolean */
	bool tmpblw90d;	/* required element of type xsd:boolean */
	bool prcpabv14d;	/* required element of type xsd:boolean */
	bool prcpblw14d;	/* required element of type xsd:boolean */
	bool prcpabv30d;	/* required element of type xsd:boolean */
	bool prcpblw30d;	/* required element of type xsd:boolean */
	bool prcpabv90d;	/* required element of type xsd:boolean */
	bool prcpblw90d;	/* required element of type xsd:boolean */
	bool precipa_USCOREr;	/* required element of type xsd:boolean */
	bool sky_USCOREr;	/* required element of type xsd:boolean */
	bool td_USCOREr;	/* required element of type xsd:boolean */
	bool temp_USCOREr;	/* required element of type xsd:boolean */
	bool wdir_USCOREr;	/* required element of type xsd:boolean */
	bool wspd_USCOREr;	/* required element of type xsd:boolean */
	bool wwa;	/* required element of type xsd:boolean */
	bool wgust;	/* required element of type xsd:boolean */
	bool iceaccum;	/* required element of type xsd:boolean */
	bool maxrh;	/* required element of type xsd:boolean */
	bool minrh;	/* required element of type xsd:boolean */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 12; } /* = unique id SOAP_TYPE_ns2__weatherParametersType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__weatherParametersType() { ns2__weatherParametersType::soap_default(NULL); }
	virtual ~ns2__weatherParametersType() { }
};
#endif

#ifndef SOAP_TYPE_ns1__NDFDgenResponse
#define SOAP_TYPE_ns1__NDFDgenResponse (31)
/* ns1:NDFDgenResponse */
struct ns1__NDFDgenResponse
{
public:
	std::string dwmlOut;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:string */
public:
	int soap_type() const { return 31; } /* = unique id SOAP_TYPE_ns1__NDFDgenResponse */
};
#endif

#ifndef SOAP_TYPE_ns1__NDFDgen
#define SOAP_TYPE_ns1__NDFDgen (32)
/* ns1:NDFDgen */
struct ns1__NDFDgen
{
public:
	std::string latitude;	/* required element of type xsd:decimal */
	std::string longitude;	/* required element of type xsd:decimal */
	enum ns2__productType product;	/* required element of type ns2:productType */
	time_t startTime;	/* required element of type xsd:dateTime */
	time_t endTime;	/* required element of type xsd:dateTime */
	enum ns2__unitType Unit;	/* required element of type ns2:unitType */
	ns2__weatherParametersType *weatherParameters;	/* optional element of type ns2:weatherParametersType */
public:
	int soap_type() const { return 32; } /* = unique id SOAP_TYPE_ns1__NDFDgen */
};
#endif

#ifndef SOAP_TYPE_ns1__NDFDgenByDayResponse
#define SOAP_TYPE_ns1__NDFDgenByDayResponse (34)
/* ns1:NDFDgenByDayResponse */
struct ns1__NDFDgenByDayResponse
{
public:
	std::string dwmlByDayOut;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:string */
public:
	int soap_type() const { return 34; } /* = unique id SOAP_TYPE_ns1__NDFDgenByDayResponse */
};
#endif

#ifndef SOAP_TYPE_ns1__NDFDgenByDay
#define SOAP_TYPE_ns1__NDFDgenByDay (35)
/* ns1:NDFDgenByDay */
struct ns1__NDFDgenByDay
{
public:
	std::string latitude;	/* required element of type xsd:decimal */
	std::string longitude;	/* required element of type xsd:decimal */
	std::string startDate;	/* required element of type xsd:date */
	std::string numDays;	/* required element of type xsd:integer */
	enum ns2__unitType Unit;	/* required element of type ns2:unitType */
	enum ns2__formatType format;	/* required element of type ns2:formatType */
public:
	int soap_type() const { return 35; } /* = unique id SOAP_TYPE_ns1__NDFDgenByDay */
};
#endif

#ifndef SOAP_TYPE_ns1__NDFDgenLatLonListResponse
#define SOAP_TYPE_ns1__NDFDgenLatLonListResponse (37)
/* ns1:NDFDgenLatLonListResponse */
struct ns1__NDFDgenLatLonListResponse
{
public:
	std::string dwmlOut;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:string */
public:
	int soap_type() const { return 37; } /* = unique id SOAP_TYPE_ns1__NDFDgenLatLonListResponse */
};
#endif

#ifndef SOAP_TYPE_ns1__NDFDgenLatLonList
#define SOAP_TYPE_ns1__NDFDgenLatLonList (38)
/* ns1:NDFDgenLatLonList */
struct ns1__NDFDgenLatLonList
{
public:
	std::string listLatLon;	/* required element of type ns2:listLatLonType */
	enum ns2__productType product;	/* required element of type ns2:productType */
	time_t startTime;	/* required element of type xsd:dateTime */
	time_t endTime;	/* required element of type xsd:dateTime */
	enum ns2__unitType Unit;	/* required element of type ns2:unitType */
	ns2__weatherParametersType *weatherParameters;	/* optional element of type ns2:weatherParametersType */
public:
	int soap_type() const { return 38; } /* = unique id SOAP_TYPE_ns1__NDFDgenLatLonList */
};
#endif

#ifndef SOAP_TYPE_ns1__NDFDgenByDayLatLonListResponse
#define SOAP_TYPE_ns1__NDFDgenByDayLatLonListResponse (40)
/* ns1:NDFDgenByDayLatLonListResponse */
struct ns1__NDFDgenByDayLatLonListResponse
{
public:
	std::string dwmlByDayOut;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:string */
public:
	int soap_type() const { return 40; } /* = unique id SOAP_TYPE_ns1__NDFDgenByDayLatLonListResponse */
};
#endif

#ifndef SOAP_TYPE_ns1__NDFDgenByDayLatLonList
#define SOAP_TYPE_ns1__NDFDgenByDayLatLonList (41)
/* ns1:NDFDgenByDayLatLonList */
struct ns1__NDFDgenByDayLatLonList
{
public:
	std::string listLatLon;	/* required element of type ns2:listLatLonType */
	std::string startDate;	/* required element of type xsd:date */
	std::string numDays;	/* required element of type xsd:integer */
	enum ns2__unitType Unit;	/* required element of type ns2:unitType */
	enum ns2__formatType format;	/* required element of type ns2:formatType */
public:
	int soap_type() const { return 41; } /* = unique id SOAP_TYPE_ns1__NDFDgenByDayLatLonList */
};
#endif

#ifndef SOAP_TYPE_ns1__GmlLatLonListResponse
#define SOAP_TYPE_ns1__GmlLatLonListResponse (43)
/* ns1:GmlLatLonListResponse */
struct ns1__GmlLatLonListResponse
{
public:
	std::string dwGmlOut;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:string */
public:
	int soap_type() const { return 43; } /* = unique id SOAP_TYPE_ns1__GmlLatLonListResponse */
};
#endif

#ifndef SOAP_TYPE_ns1__GmlLatLonList
#define SOAP_TYPE_ns1__GmlLatLonList (44)
/* ns1:GmlLatLonList */
struct ns1__GmlLatLonList
{
public:
	std::string listLatLon;	/* required element of type ns2:listLatLonType */
	time_t requestedTime;	/* required element of type xsd:dateTime */
	enum ns2__featureTypeType featureType;	/* required element of type ns2:featureTypeType */
	ns2__weatherParametersType *weatherParameters;	/* optional element of type ns2:weatherParametersType */
public:
	int soap_type() const { return 44; } /* = unique id SOAP_TYPE_ns1__GmlLatLonList */
};
#endif

#ifndef SOAP_TYPE_ns1__GmlTimeSeriesResponse
#define SOAP_TYPE_ns1__GmlTimeSeriesResponse (46)
/* ns1:GmlTimeSeriesResponse */
struct ns1__GmlTimeSeriesResponse
{
public:
	std::string dwGmlOut;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:string */
public:
	int soap_type() const { return 46; } /* = unique id SOAP_TYPE_ns1__GmlTimeSeriesResponse */
};
#endif

#ifndef SOAP_TYPE_ns1__GmlTimeSeries
#define SOAP_TYPE_ns1__GmlTimeSeries (47)
/* ns1:GmlTimeSeries */
struct ns1__GmlTimeSeries
{
public:
	std::string listLatLon;	/* required element of type ns2:listLatLonType */
	time_t startTime;	/* required element of type xsd:dateTime */
	time_t endTime;	/* required element of type xsd:dateTime */
	enum ns2__compTypeType compType;	/* required element of type ns2:compTypeType */
	enum ns2__featureTypeType featureType;	/* required element of type ns2:featureTypeType */
	std::string propertyName;	/* required element of type xsd:string */
public:
	int soap_type() const { return 47; } /* = unique id SOAP_TYPE_ns1__GmlTimeSeries */
};
#endif

#ifndef SOAP_TYPE_ns1__LatLonListSubgridResponse
#define SOAP_TYPE_ns1__LatLonListSubgridResponse (48)
/* ns1:LatLonListSubgridResponse */
struct ns1__LatLonListSubgridResponse
{
public:
	std::string listLatLonOut;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type ns2:listLatLonType */
public:
	int soap_type() const { return 48; } /* = unique id SOAP_TYPE_ns1__LatLonListSubgridResponse */
};
#endif

#ifndef SOAP_TYPE_ns1__LatLonListSubgrid
#define SOAP_TYPE_ns1__LatLonListSubgrid (51)
/* ns1:LatLonListSubgrid */
struct ns1__LatLonListSubgrid
{
public:
	std::string lowerLeftLatitude;	/* required element of type xsd:decimal */
	std::string lowerLeftLongitude;	/* required element of type xsd:decimal */
	std::string upperRightLatitude;	/* required element of type xsd:decimal */
	std::string upperRightLongitude;	/* required element of type xsd:decimal */
	std::string resolution;	/* required element of type xsd:decimal */
public:
	int soap_type() const { return 51; } /* = unique id SOAP_TYPE_ns1__LatLonListSubgrid */
};
#endif

#ifndef SOAP_TYPE_ns1__LatLonListLineResponse
#define SOAP_TYPE_ns1__LatLonListLineResponse (52)
/* ns1:LatLonListLineResponse */
struct ns1__LatLonListLineResponse
{
public:
	std::string listLatLonOut;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type ns2:listLatLonType */
public:
	int soap_type() const { return 52; } /* = unique id SOAP_TYPE_ns1__LatLonListLineResponse */
};
#endif

#ifndef SOAP_TYPE_ns1__LatLonListLine
#define SOAP_TYPE_ns1__LatLonListLine (55)
/* ns1:LatLonListLine */
struct ns1__LatLonListLine
{
public:
	std::string endPoint1Lat;	/* required element of type xsd:decimal */
	std::string endPoint1Lon;	/* required element of type xsd:decimal */
	std::string endPoint2Lat;	/* required element of type xsd:decimal */
	std::string endPoint2Lon;	/* required element of type xsd:decimal */
public:
	int soap_type() const { return 55; } /* = unique id SOAP_TYPE_ns1__LatLonListLine */
};
#endif

#ifndef SOAP_TYPE_ns1__LatLonListZipCodeResponse
#define SOAP_TYPE_ns1__LatLonListZipCodeResponse (56)
/* ns1:LatLonListZipCodeResponse */
struct ns1__LatLonListZipCodeResponse
{
public:
	std::string listLatLonOut;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type ns2:listLatLonType */
public:
	int soap_type() const { return 56; } /* = unique id SOAP_TYPE_ns1__LatLonListZipCodeResponse */
};
#endif

#ifndef SOAP_TYPE_ns1__LatLonListZipCode
#define SOAP_TYPE_ns1__LatLonListZipCode (59)
/* ns1:LatLonListZipCode */
struct ns1__LatLonListZipCode
{
public:
	std::string zipCodeList;	/* required element of type ns2:zipCodeListType */
public:
	int soap_type() const { return 59; } /* = unique id SOAP_TYPE_ns1__LatLonListZipCode */
};
#endif

#ifndef SOAP_TYPE_ns1__LatLonListSquareResponse
#define SOAP_TYPE_ns1__LatLonListSquareResponse (60)
/* ns1:LatLonListSquareResponse */
struct ns1__LatLonListSquareResponse
{
public:
	std::string listLatLonOut;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type ns2:listLatLonType */
public:
	int soap_type() const { return 60; } /* = unique id SOAP_TYPE_ns1__LatLonListSquareResponse */
};
#endif

#ifndef SOAP_TYPE_ns1__LatLonListSquare
#define SOAP_TYPE_ns1__LatLonListSquare (63)
/* ns1:LatLonListSquare */
struct ns1__LatLonListSquare
{
public:
	std::string centerPointLat;	/* required element of type xsd:decimal */
	std::string centerPointLon;	/* required element of type xsd:decimal */
	std::string distanceLat;	/* required element of type xsd:decimal */
	std::string distanceLon;	/* required element of type xsd:decimal */
	std::string resolution;	/* required element of type xsd:decimal */
public:
	int soap_type() const { return 63; } /* = unique id SOAP_TYPE_ns1__LatLonListSquare */
};
#endif

#ifndef SOAP_TYPE_ns1__CornerPointsResponse
#define SOAP_TYPE_ns1__CornerPointsResponse (64)
/* ns1:CornerPointsResponse */
struct ns1__CornerPointsResponse
{
public:
	std::string listLatLonOut;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type ns2:listLatLonType */
public:
	int soap_type() const { return 64; } /* = unique id SOAP_TYPE_ns1__CornerPointsResponse */
};
#endif

#ifndef SOAP_TYPE_ns1__CornerPoints
#define SOAP_TYPE_ns1__CornerPoints (67)
/* ns1:CornerPoints */
struct ns1__CornerPoints
{
public:
	enum ns2__sectorType sector;	/* required element of type ns2:sectorType */
public:
	int soap_type() const { return 67; } /* = unique id SOAP_TYPE_ns1__CornerPoints */
};
#endif

#ifndef SOAP_TYPE_ns1__LatLonListCityNamesResponse
#define SOAP_TYPE_ns1__LatLonListCityNamesResponse (68)
/* ns1:LatLonListCityNamesResponse */
struct ns1__LatLonListCityNamesResponse
{
public:
	std::string listCityNamesOut;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type ns2:listCityNamesType */
public:
	int soap_type() const { return 68; } /* = unique id SOAP_TYPE_ns1__LatLonListCityNamesResponse */
};
#endif

#ifndef SOAP_TYPE_ns1__LatLonListCityNames
#define SOAP_TYPE_ns1__LatLonListCityNames (71)
/* ns1:LatLonListCityNames */
struct ns1__LatLonListCityNames
{
public:
	enum ns2__displayLevelType displayLevel;	/* required element of type ns2:displayLevelType */
public:
	int soap_type() const { return 71; } /* = unique id SOAP_TYPE_ns1__LatLonListCityNames */
};
#endif

#ifndef WITH_NOGLOBAL

#ifndef SOAP_TYPE_SOAP_ENV__Header
#define SOAP_TYPE_SOAP_ENV__Header (72)
/* SOAP Header: */
struct SOAP_ENV__Header
{
public:
	int soap_type() const { return 72; } /* = unique id SOAP_TYPE_SOAP_ENV__Header */
#ifdef WITH_NOEMPTYSTRUCT
private:
	char dummy;	/* dummy member to enable compilation */
#endif
};
#endif

#endif

#ifndef WITH_NOGLOBAL

#ifndef SOAP_TYPE_SOAP_ENV__Code
#define SOAP_TYPE_SOAP_ENV__Code (73)
/* SOAP Fault Code: */
struct SOAP_ENV__Code
{
public:
	char *SOAP_ENV__Value;	/* optional element of type xsd:QName */
	struct SOAP_ENV__Code *SOAP_ENV__Subcode;	/* optional element of type SOAP-ENV:Code */
public:
	int soap_type() const { return 73; } /* = unique id SOAP_TYPE_SOAP_ENV__Code */
};
#endif

#endif

#ifndef WITH_NOGLOBAL

#ifndef SOAP_TYPE_SOAP_ENV__Detail
#define SOAP_TYPE_SOAP_ENV__Detail (75)
/* SOAP-ENV:Detail */
struct SOAP_ENV__Detail
{
public:
	char *__any;
	int __type;	/* any type of element <fault> (defined below) */
	void *fault;	/* transient */
public:
	int soap_type() const { return 75; } /* = unique id SOAP_TYPE_SOAP_ENV__Detail */
};
#endif

#endif

#ifndef WITH_NOGLOBAL

#ifndef SOAP_TYPE_SOAP_ENV__Reason
#define SOAP_TYPE_SOAP_ENV__Reason (78)
/* SOAP-ENV:Reason */
struct SOAP_ENV__Reason
{
public:
	char *SOAP_ENV__Text;	/* optional element of type xsd:string */
public:
	int soap_type() const { return 78; } /* = unique id SOAP_TYPE_SOAP_ENV__Reason */
};
#endif

#endif

#ifndef WITH_NOGLOBAL

#ifndef SOAP_TYPE_SOAP_ENV__Fault
#define SOAP_TYPE_SOAP_ENV__Fault (79)
/* SOAP Fault: */
struct SOAP_ENV__Fault
{
public:
	char *faultcode;	/* optional element of type xsd:QName */
	char *faultstring;	/* optional element of type xsd:string */
	char *faultactor;	/* optional element of type xsd:string */
	struct SOAP_ENV__Detail *detail;	/* optional element of type SOAP-ENV:Detail */
	struct SOAP_ENV__Code *SOAP_ENV__Code;	/* optional element of type SOAP-ENV:Code */
	struct SOAP_ENV__Reason *SOAP_ENV__Reason;	/* optional element of type SOAP-ENV:Reason */
	char *SOAP_ENV__Node;	/* optional element of type xsd:string */
	char *SOAP_ENV__Role;	/* optional element of type xsd:string */
	struct SOAP_ENV__Detail *SOAP_ENV__Detail;	/* optional element of type SOAP-ENV:Detail */
public:
	int soap_type() const { return 79; } /* = unique id SOAP_TYPE_SOAP_ENV__Fault */
};
#endif

#endif

/******************************************************************************\
 *                                                                            *
 * Typedefs                                                                   *
 *                                                                            *
\******************************************************************************/

#ifndef SOAP_TYPE__QName
#define SOAP_TYPE__QName (5)
typedef char *_QName;
#endif

#ifndef SOAP_TYPE__XML
#define SOAP_TYPE__XML (6)
typedef char *_XML;
#endif

#ifndef SOAP_TYPE_xsd__date
#define SOAP_TYPE_xsd__date (9)
typedef std::string xsd__date;
#endif

#ifndef SOAP_TYPE_xsd__decimal
#define SOAP_TYPE_xsd__decimal (10)
typedef std::string xsd__decimal;
#endif

#ifndef SOAP_TYPE_xsd__integer
#define SOAP_TYPE_xsd__integer (11)
typedef std::string xsd__integer;
#endif

#ifndef SOAP_TYPE_ns2__latLonPairType
#define SOAP_TYPE_ns2__latLonPairType (17)
typedef std::string ns2__latLonPairType;
#endif

#ifndef SOAP_TYPE_ns2__listLatLonType
#define SOAP_TYPE_ns2__listLatLonType (18)
typedef std::string ns2__listLatLonType;
#endif

#ifndef SOAP_TYPE_ns2__zipCodeType
#define SOAP_TYPE_ns2__zipCodeType (19)
typedef std::string ns2__zipCodeType;
#endif

#ifndef SOAP_TYPE_ns2__zipCodeListType
#define SOAP_TYPE_ns2__zipCodeListType (20)
typedef std::string ns2__zipCodeListType;
#endif

#ifndef SOAP_TYPE_ns2__listCityNamesType
#define SOAP_TYPE_ns2__listCityNamesType (23)
typedef std::string ns2__listCityNamesType;
#endif


/******************************************************************************\
 *                                                                            *
 * Externals                                                                  *
 *                                                                            *
\******************************************************************************/


#endif

/* End of soapStub.h */
